#!/usr/bin/env node

/**
 * Test script to validate LiveKit streaming SSE parsing implementation
 * Tests Option A: LiveKit parsing streaming SSE from /api/food-chat
 */

const http = require('http');
const { URL } = require('url');

console.log('ðŸ§ª Testing LiveKit streaming SSE implementation...');\n\n// Test configuration\nconst BASE_URL = 'http://localhost:3000';\nconst TEST_MESSAGE = 'I want Thai food';\n\n// ANSI color codes\nconst colors = {\n  green: '\\x1b[32m',\n  red: '\\x1b[31m',\n  yellow: '\\x1b[33m',\n  blue: '\\x1b[34m',\n  reset: '\\x1b[0m',\n  bold: '\\x1b[1m'\n};\n\nfunction log(color, message) {\n  console.log(`${colors[color]}${message}${colors.reset}`);\n}\n\n// Test 1: Verify /api/food-chat returns streaming SSE format\nfunction testStreamingAPI() {
  return new Promise((resolve, reject) => {
    log('blue', '\nðŸ“¡ Test 1: Checking /api/food-chat streaming response format...');
    
    const postData = JSON.stringify({
      messages: [{ role: 'user', content: TEST_MESSAGE }]
    });\n    \n    const url = new URL('/api/food-chat', BASE_URL);\n    const options = {\n      hostname: url.hostname,\n      port: url.port || 3000,\n      path: url.pathname,\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Content-Length': Buffer.byteLength(postData)\n      }\n    };\n    \n    const req = http.request(options, (res) => {\n      let responseData = '';\n      let hasSSEFormat = false;\n      let hasTextDelta = false;\n      let hasToolResults = false;\n      \n      res.on('data', (chunk) => {\n        const data = chunk.toString();\n        responseData += data;\n        \n        // Check for SSE format\n        if (data.includes('data: {')) {\n          hasSSEFormat = true;\n          log('green', 'âœ… Found SSE format: data: {...}');\n        }\n        \n        // Check for textDelta\n        if (data.includes('\"textDelta\"')) {\n          hasTextDelta = true;\n          log('green', 'âœ… Found textDelta in stream');\n        }\n        \n        // Check for toolResults  \n        if (data.includes('\"toolResults\"')) {\n          hasToolResults = true;\n          log('green', 'âœ… Found toolResults in stream');\n        }\n      });\n      \n      res.on('end', () => {\n        log('blue', `ðŸ“Š API Response Summary:`);\n        log(hasSSEFormat ? 'green' : 'red', `   SSE Format: ${hasSSEFormat ? 'âœ…' : 'âŒ'}`);\n        log(hasTextDelta ? 'green' : 'red', `   TextDelta: ${hasTextDelta ? 'âœ…' : 'âŒ'}`);\n        log(hasToolResults ? 'green' : 'red', `   ToolResults: ${hasToolResults ? 'âœ…' : 'âŒ'}`);\n        \n        if (hasSSEFormat && hasTextDelta) {\n          resolve({ success: true, hasToolResults });\n        } else {\n          reject(new Error('API does not return expected SSE format'));\n        }\n      });\n    });\n    \n    req.on('error', (err) => {\n      reject(new Error(`API request failed: ${err.message}`));\n    });\n    \n    req.write(postData);\n    req.end();\n  });\n}\n\n// Test 2: Simulate LiveKit SSE parsing logic\nfunction testSSEParsing() {\n  log('blue', '\\nðŸ” Test 2: Simulating LiveKit SSE parsing logic...');\n  \n  // Sample SSE data that should come from API\n  const sampleSSEData = [\n    'data: {\"textDelta\": \"Great choice! \"}\\n\\n',\n    'data: {\"textDelta\": \"I found some excellent Thai restaurants.\"}\\n\\n',\n    'data: {\"toolResults\": [{\"toolName\": \"searchRestaurants\", \"result\": \"{\\\\\"restaurants\\\\\": []};\"}]}\\n\\n'\n  ];\n  \n  try {\n    let accumulatedText = '';\n    let toolResults = [];\n    \n    for (const chunk of sampleSSEData) {\n      const lines = chunk.split('\\n');\n      \n      for (const line of lines) {\n        if (line.startsWith('data: ')) {\n          const data = JSON.parse(line.slice(6));\n          \n          if (data.textDelta) {\n            accumulatedText += data.textDelta;\n            log('green', `âœ… Parsed textDelta: \"${data.textDelta}\"`);\n          }\n          \n          if (data.toolResults && Array.isArray(data.toolResults)) {\n            toolResults.push(...data.toolResults);\n            log('green', `âœ… Parsed toolResults: ${data.toolResults.length} results`);\n          }\n        }\n      }\n    }\n    \n    log('blue', `ðŸ“Š Parsing Summary:`);\n    log('green', `   Accumulated Text: \"${accumulatedText}\"`);\n    log('green', `   Tool Results: ${toolResults.length} results`);\n    \n    return { accumulatedText, toolResults };\n  } catch (error) {\n    log('red', `âŒ SSE parsing failed: ${error.message}`);\n    throw error;\n  }\n}\n\n// Test 3: Verify card rendering logic\nfunction testCardRendering() {\n  log('blue', '\\nðŸŽ¨ Test 3: Testing card rendering logic...');\n  \n  const mockToolResults = [\n    {\n      toolName: 'searchRestaurants',\n      result: JSON.stringify({\n        restaurants: [{\n          name: 'Noodle Express',\n          cuisine: 'Thai',\n          rating: 4.5\n        }],\n        speechSummary: 'Found 1 Thai restaurant'\n      })\n    }\n  ];\n  \n  try {\n    for (const toolResult of mockToolResults) {\n      const parsedResult = JSON.parse(toolResult.result);\n      log('green', `âœ… Successfully parsed tool result for: ${toolResult.toolName}`);\n      log('green', `   Speech Summary: \"${parsedResult.speechSummary}\"`);\n      log('green', `   Data: ${JSON.stringify(parsedResult).substring(0, 100)}...`);\n    }\n    \n    return true;\n  } catch (error) {\n    log('red', `âŒ Card rendering test failed: ${error.message}`);\n    throw error;\n  }\n}\n\n// Main test runner\nasync function runTests() {\n  try {\n    log('bold', 'ðŸš€ Starting LiveKit SSE Implementation Tests');\n    log('yellow', `ðŸ“ Testing against: ${BASE_URL}`);\n    log('yellow', `ðŸ’¬ Test message: \"${TEST_MESSAGE}\"`);\n    \n    // Test 1: API format\n    const apiResult = await testStreamingAPI();\n    \n    // Test 2: SSE parsing  \n    const parseResult = testSSEParsing();\n    \n    // Test 3: Card rendering\n    const cardResult = testCardRendering();\n    \n    // Summary\n    log('bold', '\\nðŸŽ‰ All tests passed! LiveKit Option A implementation is working:');\n    log('green', '   âœ… /api/food-chat returns proper SSE format');\n    log('green', '   âœ… SSE parsing logic handles textDelta and toolResults');\n    log('green', '   âœ… Card rendering logic processes tool results');\n    \n    if (apiResult.hasToolResults) {\n      log('green', '   âœ… API includes tool results (cards will appear)');\n    } else {\n      log('yellow', '   âš ï¸  No tool results in test (cards may not appear for this query)');\n    }\n    \n    log('blue', '\\nðŸŽ¯ LiveKit can now provide multimodal UX: voice conversation + visual cards!');\n    \n  } catch (error) {\n    log('red', `\\nâŒ Test failed: ${error.message}`);\n    log('yellow', '\\nðŸ”§ Troubleshooting steps:');\n    log('yellow', '   1. Make sure server is running: npm run dev');\n    log('yellow', '   2. Verify /api/food-chat endpoint is working');\n    log('yellow', '   3. Check that AI SDK is properly configured');\n    process.exit(1);\n  }\n}\n\n// Handle graceful shutdown\nprocess.on('SIGINT', () => {\n  log('yellow', '\\nðŸ‘‹ Test interrupted by user');\n  process.exit(0);\n});\n\nif (require.main === module) {\n  runTests();\n}\n\nmodule.exports = { runTests };\n